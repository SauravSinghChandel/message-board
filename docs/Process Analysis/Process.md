# Process Analysis Document

## Initial phase

### Deciding the meeting details

As a team, we decided to hold team meetings over in discord
as it was more convenient for our schedules. We decided that 
the scrum master and note taker roles would be assigned 
randomly in the beginning of the sprint, and then in subsequent
meetings, we would assign the roles to people who had not been 
assigned a role before. As the sprint progressed, people more
familiar with the agenda of the meeting volunteered to be the 
scrum master. 

### Deciding the pull request merge methodology

We decided to agree on a PR deadline at the end of every meeting.
We usually had a tentative deadline as well as a final deadline,
to account for delays or to incorporate feedback. 

We agreed on Saurav to merge the pull requests submitted after 
the code review. This process was unchanged for all sprints.

### Meeting process

After deciding the scrum master and the note taker,
We opened with a quick refresher of the previous meeting and then 
explained the agenda and how it tied to the current meeting.

Then, we all discussed what tasks were priority and who would handle each one, 
what we had finished and what work was being done and on and any 
tips / concerns for other group members or the group as a whole.

We ended with a tentative and final pull request submission dates.

## Documentation

### Tracking progress

Initally, we decided to primarily rely on the meeting notes to 
keep us informed about the status of the assigned tasks and responsiblities.
But we realised the inefficiency of this during sprint 1, and during
sprint 2, after receiving our feedback we agreed to primarily rely
on the kanban board. It made tracking progress and responsiblites 
much easier, and in addition, it also made the statuses of the tasks
easy to view. During sprint 3, we started using the issues board
to raise problems and to keep better task of coding tasks. 

Meeting notes were primarily used to document meeting happenings
rather than task statuses after sprint 1. During sprint 2, we 
decided that it would be a much better idea to push the consolidated
meeting notes at the end of the sprint, something we decided to do
in sprint 3 as well. 

### Performance reviews

During sprint 1, we believed that the best way to do performance
reviews would be to aggregate all our opinions of others into a 
table with concise sentences describing everyone's contributions
and what they uniquely brought to the team. 

But after concerns were raised in the feedback, we decided to be more
specific and also highlight the shortcomings of each person in an effort
to point them to specific directions to improve. The feedback was received
well by the team. One mistake we made, was not keeping records of improvement
in subsequent meetings or the follow ups done.

The feedback for sprint 2 made us realise that this method was insufficient.
We would have liked to add a section for performance in the meeting notes,
to track each person's individual performance better. We believe that 
this would have lead to better improvement. 

### Code reviews

Initially, for sprint 1, we decided to do a single code review at the 
end of the sprint. After receiving the feedback, we quickly realised 
that this was the wrong approach and we decided to do code reviews 
every time a major pull request needed approval. This was the approach
in sprint 2.

After receiving the feedback for sprint 2, we realised that we 
needed to be more specific. We would have liked to have more comprehensive
reviews that addressed code styles, adherence to good programming practices,
consideration for SOLID, de-coupling and more use of common patterns. 

## Sprint progress

We first decided on the activities that needed to be done for the 
sprint. From sprint 2 onwards, we put them in the project backlog
in the Kanban board. 

Then, we decided on the current activity to work on. Each person was 
assigned a specific domain in general, namely server, session management,
app logic, HTML/Templating and storage/database. The activity was decomposed
into tasks that would involve each of these domains, so every person 
could work on one of those tasks. The tasks were then added to the to-do
section on the Kanban board and everyone would start working on their assigned 
tasks.

There was constant communication between the team to ensure that 
the tasks we were working on was progressing well. Once each task 
was done, we would submit our pull requests and the code reviews 
would begin, and we would give each other feedbacks and make sure
the code worked. If issues were spotted, they would be added to 
the issues board. We also made sure to add the pull 
requests to the Kanban board if approved. Once the pull requests 
were approved, then we would move on to the next activity, adding
them as a task submission on the issues board. 

Concurrently, the UML diagrams and the architecture diagrams would
be updated by the responsible people, along with the attribution
table.